========================================================================================================================
                                     COMMON SORTING ALGORITHMS FOR CODING INTERVIEWS
========================================================================================================================

| Name           | Short Description             | When to Use                    | Limitations                        |
|----------------|-------------------------------|--------------------------------|------------------------------------|
| Bubble Sort    | Swaps adjacent elements if    | Educational use or very small, | Extremely slow O(n^2);             |
|                | in the wrong order.           | nearly sorted datasets.        | inefficient for large data.        |
|----------------|-------------------------------|--------------------------------|------------------------------------|
| Insertion Sort | Builds sorted list one item   | Best for small or nearly       | Poor scaling for large             |
|                | at a time by inserting.       | sorted data (O(n) best case).  | datasets (O(n^2)).                 |
|----------------|-------------------------------|--------------------------------|------------------------------------|
| Merge Sort     | Divide & Conquer: Splits,     | Large datasets; sorting linked | High memory usage; requires        |
|                | sorts, and merges halves.     | lists; when stability is key.  | O(n) extra space for arrays.       |
|----------------|-------------------------------|--------------------------------|------------------------------------|
| Quick Sort     | Partitions array around a     | General-purpose in-memory      | Worst case O(n^2) with poor        |
|                | pivot element.                | sorting; very fast in practice.| pivots; unstable sorting.          |
|----------------|-------------------------------|--------------------------------|------------------------------------|
| Heap Sort      | Uses a Binary Heap to find    | When memory is limited (O(1)   | Slower than Quick Sort;            |
|                | and extract max/min.          | space) but need O(n log n).    | unstable sorting.                  |
|----------------|-------------------------------|--------------------------------|------------------------------------|
| Binary Tree    | Inserts elements into a BST,  | When data arrives as a stream  | Unbalanced trees lead to           |
| Sort           | then does in-order traversal. | and needs to stay sorted.      | O(n^2) performance.                |
|----------------|-------------------------------|--------------------------------|------------------------------------|
| Bucket Sort    | Distributes elements into     | Uniformly distributed floating | Performance collapses if data      |
|                | "buckets" and sorts them.     | point numbers.                 | is heavily skewed or clumped.      |
|----------------|-------------------------------|--------------------------------|------------------------------------|
| Radix Sort     | Sorts digit by digit using    | Sorting many integers or       | Limited to data that can be        |
|                | stable sub-sorts.             | fixed-length strings.          | broken into "keys" (integers).     |
|----------------|-------------------------------|--------------------------------|------------------------------------|
| Counting Sort  | Counts unique values to find  | When the range of integers is  | Not for large ranges or            |
|                | final positions.              | small relative to array size.  | non-integer data types.            |
------------------------------------------------------------------------------------------------------------------------

KEY INTERVIEW CONSTRAINTS & LIMITS:
-----------------------------------
1. THE O(N LOG N) BARRIER: No comparison-based sort can be faster than O(n log n). 
   To get O(n), you must use non-comparison sorts like Radix or Counting Sort.
2. STABILITY: A "Stable" sort (Merge, Insertion) preserves the relative order of 
   equal elements. This is vital for multi-level sorting.
3. SPACE COMPLEXITY: Interviewers often prioritize "In-Place" algorithms (Quick, 
   Heap) if memory is a constraint.
4. DATA INTEGRITY: If storing these algorithms or datasets on an external SSD, 
   be sure to connect it to a power source at least once a year to prevent data 
   loss in the flash cells.

========================================================================================================================